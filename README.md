# 8-Week DSA Mastery Plan

> From Zero to Medium LeetCode - Data Structures & Algorithms in Python

**Timeline**: January 8, 2026 - February 26, 2026
**Daily Budget**: 2.5 hours
**Goal**: Solve Medium LeetCode problems confidently for software engineering interviews

---

## Resources

- **Textbook**: "Data Structures and Algorithms in Python" by Goodrich, Tamassia & Goldwasser
- **NeetCode 150**: [neetcode.io/practice](https://neetcode.io/practice)
- **LeetCode**: [leetcode.com](https://leetcode.com)

---

## Daily Success Protocol (2.5 Hours)

1. **Theory (45 min):** Read the assigned sections from the textbook
2. **Implementation (1 hr):** Solve the specified textbook exercise in your repo
3. **Application (45 min):** Solve the linked LeetCode problem to see the concept in an interview context

### Definition of COMPLETE

A day is only considered **COMPLETE** when all three components are finished:
- ✅ Reading done
- ✅ Textbook exercise(s) implemented
- ✅ LeetCode problem solved

This tri-part approach ensures:
- **Reading** provides theoretical foundation
- **Exercises** cement fundamental understanding
- **LeetCode** shows real-world application

---

## Phase 1: Foundations & The Pythonic Way (Weeks 1-2)

| Date | Textbook Focus | Daily Deliverable (Textbook Exercise) | LeetCode/Interview Goal |
|------|---------------|--------------------------------------|------------------------|
| **Jan 8** | Ch 1.1–1.2 (Objects) | **R-1.1 & R-1.2:** Implement `is_multiple` and `is_even` without arithmetic operators | [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) |
| **Jan 9** | Ch 1.3–1.5 (Functions) | **R-1.4 & R-1.11:** Sum of squares and list comprehensions | [Valid Anagram](https://leetcode.com/problems/valid-anagram/) |
| **Jan 10** | Ch 1.6–1.9 (I/O & Ops) | **C-1.20 & C-1.21:** Implement `shuffle` and reverse lines from input | [Two Sum](https://leetcode.com/problems/two-sum/) |
| **Jan 11** | **REST DAY** | Catch up on repo organization or documentation | — |
| **Jan 12** | Ch 3.1–3.3 (Big-O) | **R-3.1 & R-3.2:** Analytical justification of growth functions | Review complexity of all solved problems |
| **Jan 13** | Ch 3.4–3.5 (Asymptotic) | **C-3.35 & C-3.36:** Space/Time trade-off analysis | [Group Anagrams](https://leetcode.com/problems/group-anagrams/) |
| **Jan 14** | Ch 1 Project | **P-1.32:** Build a console-based Calculator simulation | [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/) |

---

## Phase 2: Recursion & Linear Sequences (Weeks 3-4)

| Date | Textbook Focus | Daily Deliverable (Textbook Exercise) | LeetCode/Interview Goal |
|------|---------------|--------------------------------------|------------------------|
| **Jan 15** | Ch 4.1–4.2 (Recursion) | **R-4.1 & R-4.6:** Recursive `max` finding and Harmonic number calculation | [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/) |
| **Jan 16** | Ch 4.3–4.4 (Binary Rec) | **R-4.7 & C-4.9:** Recursive string-to-int conversion and min/max finding | [Binary Search](https://leetcode.com/problems/binary-search/) |
| **Jan 17** | Ch 4 Projects | **P-4.23:** Recursive `find` for file systems | [Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) |
| **Jan 18** | **REST DAY** | — | — |
| **Jan 19** | Ch 5.1–5.3 (Arrays) | **R-5.4 & R-5.7:** Update `DynamicArray` and find repeated integers | [3Sum](https://leetcode.com/problems/3sum/) |
| **Jan 20** | Ch 5.4–5.5 (Efficiency) | **C-5.25:** Implement `remove_all` for a list | [Container With Most Water](https://leetcode.com/problems/container-with-most-water/) |
| **Jan 21** | Ch 5 Project | **P-5.33:** Implement a complete Matrix class with addition/multiplication | [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/) |

---

## Phase 3: Nonlinear Structures (Weeks 5-6)

### Week 5: Trees & Binary Search Trees (Jan 22 – Jan 28)

| Date | Textbook Focus | Daily Deliverable (Textbook Exercise) | LeetCode/Interview Goal |
|------|---------------|--------------------------------------|------------------------|
| **Jan 22** | Ch 7.1–7.2 (Singly LL) | **C-7.26:** Concatenate two `LinkedQueue` instances in O(1) | [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) |
| **Jan 23** | Ch 7.3–7.4 (Doubly LL) | **R-7.11 & R-7.13:** Positional list `max` and `find` methods | [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) |
| **Jan 24** | Ch 7 Project | **P-7.44:** Build a text editor using the Positional List ADT | [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) |
| **Jan 25** | **REST DAY** | — | — |
| **Jan 26** | Ch 6.1 (Stacks) | **R-6.3 & R-6.5:** Stack transfer and list reversal via stack | [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/) |
| **Jan 27** | Ch 6.2–6.3 (Queues) | **C-6.22:** Implement non-recursive Postfix expression evaluation | [Min Stack](https://leetcode.com/problems/min-stack/) |
| **Jan 28** | Ch 6 Project | **P-6.34:** Full Postfix calculator program | [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/) |

### Week 6: Trees & Heaps (Jan 29 – Feb 4)

| Date | Textbook Focus | Daily Deliverable (Textbook Exercise) | LeetCode/Interview Goal |
|------|---------------|--------------------------------------|------------------------|
| **Jan 29** | Ch 8.1–8.2 (Tree ADTs) | **R-8.1 & R-8.7:** Recursive algorithms for counting leaves and computing tree height | [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/) |
| **Jan 30** | Ch 8.3 (Tree Impl.) | **R-8.16:** Write a function to determine if a node is the root of a tree without using class methods | [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) |
| **Jan 31** | Ch 8.4 (Traversals) | **C-8.38:** Implement an algorithm that prints the "parenthetic representation" of a tree | [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) |
| **Feb 1** | **REST DAY** | — | — |
| **Feb 2** | Ch 11.1 (BSTs) | **R-11.1 & R-11.3:** Illustrate BST insertions and describe a recursive search for a key | [Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/) |
| **Feb 3** | Ch 11.1.3 (BST Ops) | **C-11.32:** Implement an algorithm to find the "next" node in an In-order traversal | [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) |
| **Feb 4** | Ch 8 Projects | **P-8.64:** Implement the Binary Tree ADT using the array-based representation | [Kth Smallest Element in BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) |

---

## Phase 4: Optimization & Graphs (Weeks 7-8)

### Week 7: Priority Queues & Heaps (Feb 5 – Feb 11)

| Date | Textbook Focus | Daily Deliverable (Textbook Exercise) | LeetCode/Interview Goal |
|------|---------------|--------------------------------------|------------------------|
| **Feb 5** | Ch 9.1–9.2 (PQ ADT) | **R-9.1 & R-9.3:** Analysis of PQ operations using sorted vs. unsorted lists | [Last Stone Weight](https://leetcode.com/problems/last-stone-weight/) |
| **Feb 6** | Ch 9.3 (Heaps) | **R-9.7:** Illustrate the state of a heap after a series of `add` and `remove_min` operations | [Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/) |
| **Feb 7** | Ch 9.3.6 (Bottom-Up) | **C-9.28:** Implement a method that determines if a given array represents a valid Min-Heap | [K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/) |
| **Feb 8** | **REST DAY** | — | — |
| **Feb 9** | Ch 9.4 (Sorting) | **R-9.16:** Compare the number of comparisons in Selection-Sort vs. Heap-Sort | [Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/) |
| **Feb 10** | Ch 9.5 (Adaptable PQ) | **C-9.51:** Implement an `update` method for a heap that changes an element's priority | [Task Scheduler](https://leetcode.com/problems/task-scheduler/) |
| **Feb 11** | Ch 9 Projects | **P-9.52:** Build a full Min-Heap class from scratch with `bubble_up` and `bubble_down` | [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/) |

### Week 8: Maps, Hashing, & Graphs (Feb 12 – Feb 18)

| Date | Textbook Focus | Daily Deliverable (Textbook Exercise) | LeetCode/Interview Goal |
|------|---------------|--------------------------------------|------------------------|
| **Feb 12** | Ch 10.1–10.2 (Maps) | **R-10.1:** Implement a simple Map using an unsorted list | [Design HashMap](https://leetcode.com/problems/design-hashmap/) |
| **Feb 13** | Ch 10.2 (Hashing) | **R-10.4 & R-10.7:** Practice resolving collisions using Linear Probing and Chaining | [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/) |
| **Feb 14** | Ch 10.4 (Skip Lists) | **C-10.33:** Optimize `ChainHashMap` to store single items without using a secondary list | [Two Sum](https://leetcode.com/problems/two-sum/) (Re-solve using a Map) |
| **Feb 15** | **REST DAY** | — | — |
| **Feb 16** | Ch 11.2–11.3 (AVL) | **R-11.7:** Illustrate the rotations needed to rebalance an AVL tree after insertion | [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/) |
| **Feb 17** | Ch 11.4 (Splay Trees) | **C-11.47:** Compare Pre-order traversals of Splay Trees vs. Red-Black Trees | [Insert into a Binary Search Tree](https://leetcode.com/problems/insert-into-a-binary-search-tree/) |
| **Feb 18** | Ch 10 Projects | **P-10.52:** Implement an `OrderedDict` class that maintains FIFO order | [LRU Cache](https://leetcode.com/problems/lru-cache/) |

### Week 9: Sorting & Graph Algorithms (Feb 19 – Feb 26)

| Date | Textbook Focus | Daily Deliverable (Textbook Exercise) | LeetCode/Interview Goal |
|------|---------------|--------------------------------------|------------------------|
| **Feb 19** | Ch 12.1–12.3 (Sorting) | **R-12.1 & R-12.7:** Analysis of Merge-Sort and Quick-Sort on already sorted arrays | [Sort an Array](https://leetcode.com/problems/sort-an-array/) |
| **Feb 20** | Ch 14.1 (Graph ADT) | **R-14.1:** Illustrate a graph using an Adjacency Matrix and an Adjacency List | [Find Center of Star Graph](https://leetcode.com/problems/find-center-of-star-graph/) |
| **Feb 21** | Ch 14.3.1 (DFS) | **R-14.7:** Draw the DFS tree and identify back-edges and tree-edges | [Number of Islands](https://leetcode.com/problems/number-of-islands/) |
| **Feb 22** | **REST DAY** | — | — |
| **Feb 23** | Ch 14.3.3 (BFS) | **C-14.28:** Implement a non-recursive version of DFS using a stack | [Rotting Oranges](https://leetcode.com/problems/rotting-oranges/) |
| **Feb 24** | Ch 14.5 (Topological) | **R-14.13:** Perform a topological sort on a Directed Acyclic Graph (DAG) | [Course Schedule](https://leetcode.com/problems/course-schedule/) |
| **Feb 25** | Ch 14.6 (Shortest Path) | **R-14.16:** Trace Dijkstra's algorithm to find the shortest path from a source | [Network Delay Time](https://leetcode.com/problems/network-delay-time/) |
| **Feb 26** | **FINAL REVIEW** | **P-14.48:** Build a "Degree of Separation" finder between two vertices | [Clone Graph](https://leetcode.com/problems/clone-graph/) |

---

## Repo Deliverable Template

For each day, your commit should include:

### 1. Code File with Template Header

```python
"""
Exercise: R-1.1 - is_multiple(n, m)
Date: 2026-01-08
Source: Goodrich et al., Chapter 1

Description:
Write a short Python function, is_multiple(n, m), that takes two integer
values and returns True if n is a multiple of m, that is, n = mi for some
integer i, and False otherwise.

Time Complexity: O(1)
Space Complexity: O(1)

Key Insights:
- Using modulo operator to check divisibility
- Edge cases: when m is 0, should handle gracefully
"""

def is_multiple(n, m):
    """
    Check if n is a multiple of m.

    Args:
        n (int): The potential multiple
        m (int): The potential divisor

    Returns:
        bool: True if n is a multiple of m, False otherwise
    """
    if m == 0:
        return False
    return n % m == 0


def main():
    """Test cases"""
    # Basic tests
    assert is_multiple(20, 5) == True
    assert is_multiple(21, 5) == False

    # Edge cases
    assert is_multiple(0, 5) == True
    assert is_multiple(5, 0) == False
    assert is_multiple(-20, 5) == True

    print("All tests passed!")


if __name__ == "__main__":
    main()
```

### 2. Complexity Analysis

At the top of each file, include:
- **Time Complexity**: Big-O notation with brief explanation
- **Space Complexity**: Big-O notation with brief explanation
- **Key Insights**: 1-2 bullet points about the approach

### 3. Test Cases

Include a `main()` block or unit tests proving the solution works:
- Basic functionality tests
- Edge cases
- Boundary conditions

### 4. Commit Message Format

```
Day X: [Date] - [Topic]

Textbook:
- R-1.1: is_multiple
- R-1.2: is_even

LeetCode:
- 217: Contains Duplicate (Easy)

Time: 2.5 hours
Status: Complete
```

---

## Progress Tracking

Mark your daily progress:

- [ ] **Week 1** (Jan 8-14): Python Fundamentals & Big-O
- [ ] **Week 2** (Jan 15-21): Recursion & Arrays
- [ ] **Week 3** (Jan 22-28): Linked Lists & Stacks
- [ ] **Week 4** (Jan 29-Feb 4): Trees & BSTs
- [ ] **Week 5** (Feb 5-11): Heaps & Priority Queues
- [ ] **Week 6** (Feb 12-18): Maps, Hashing, & Search Trees
- [ ] **Week 7** (Feb 19-26): Sorting & Graph Algorithms

---

## Success Metrics

By February 26, 2026, you should be able to:

- [ ] Solve Medium LeetCode problems independently
- [ ] Explain time/space complexity for all solutions
- [ ] Implement core data structures from scratch
- [ ] Choose the right data structure for a given problem
- [ ] Optimize brute-force solutions systematically

---

## Getting Started

**Today is Day 1 (January 8, 2026)**

1. Read Ch 1.1-1.2 (Objects in Python) - 45 minutes
2. Implement R-1.1 (`is_multiple`) and R-1.2 (`is_even`) - 1 hour
3. Solve [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) - 45 minutes
4. Commit your work and mark Day 1 complete

**Remember**: A day is only COMPLETE when all three components (Reading + Exercise + LeetCode) are done.

Let's begin your 8-week journey to DSA mastery!
